import React, { useRef, useEffect } from 'react';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { GameState, CameraState } from '../types/game';

interface ArcadeMachine3DProps {
  gameState: GameState;
  cameraState: CameraState;
  containerRef: React.RefObject<HTMLDivElement>;
}

export const ArcadeMachine3D: React.FC<ArcadeMachine3DProps> = ({
  gameState,
  cameraState,
  containerRef,
}) => {
  const sceneRef = useRef<THREE.Scene | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const arcadeModelRef = useRef<THREE.Group | null>(null);
  const gameDisplayRef = useRef<THREE.Mesh | null>(null);
  const animationIdRef = useRef<number>();
  const particlesRef = useRef<THREE.Points | null>(null);

  useEffect(() => {
    if (!containerRef.current) return;

    // ÂàùÂßãÂåñ Three.js Â†¥ÊôØ
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0a);
    sceneRef.current = scene;

    // ÂâµÂª∫Áõ∏Ê©ü
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    cameraRef.current = camera;

    // ÂâµÂª∫Ê∏≤ÊüìÂô®
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    rendererRef.current = renderer;

    // Ê∑ªÂä†Âà∞ DOM
    containerRef.current.appendChild(renderer.domElement);

    // Ê∑ªÂä†ÁáàÂÖâ
    setupLighting(scene);

    // ÂâµÂª∫ÂΩ©Ëâ≤Á≤íÂ≠êÁ≥ªÁµ±
    createParticleSystem(scene);

    // ËºâÂÖ• 3D Ê®°Âûã
    loadArcadeModel(scene);

    // ÂâµÂª∫ÈÅäÊà≤Áï´Èù¢
    createGameDisplay(scene);

    // ÂãïÁï´Âæ™Áí∞
    const animate = () => {
      animationIdRef.current = requestAnimationFrame(animate);
      
      // Êõ¥Êñ∞Áõ∏Ê©ü‰ΩçÁΩÆ
      updateCameraPosition();
      
      // Êõ¥Êñ∞ÈÅäÊà≤Áï´Èù¢
      updateGameDisplay();
      
      // Êõ¥Êñ∞Á≤íÂ≠êÂãïÁï´
      updateParticleAnimation();
      
      renderer.render(scene, camera);
    };
    animate();

    // Á™óÂè£Â§ßÂ∞èË™øÊï¥
    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener('resize', handleResize);

    // Ê∏ÖÁêÜÂáΩÊï∏
    return () => {
      window.removeEventListener('resize', handleResize);
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current);
      }
      if (containerRef.current && renderer.domElement) {
        containerRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, [containerRef]);

  // Ë®≠ÁΩÆÁáàÂÖâ
  const setupLighting = (scene: THREE.Scene) => {
    // Áí∞Â¢ÉÂÖâ
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);

    // ‰∏ªÊñπÂêëÂÖâ
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    directionalLight.position.set(3, 3, 3);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    directionalLight.shadow.camera.left = -10;
    directionalLight.shadow.camera.right = 10;
    directionalLight.shadow.camera.top = 10;
    directionalLight.shadow.camera.bottom = -10;
    scene.add(directionalLight);

    // ÈªûÂÖâÊ∫ê - ÈÅäÊà≤Ê©üÂÖßÈÉ®ÁôºÂÖâ
    const pointLight = new THREE.PointLight(0x4a90e2, 0.8, 5);
    pointLight.position.set(0, 1, 0);
    scene.add(pointLight);

    // ËÅöÂÖâÁáà - ÈÅäÊà≤Ê©üÈ†ÇÈÉ®
    const spotLight = new THREE.SpotLight(0xffffff, 0.5);
    spotLight.position.set(0, 4, 0);
    spotLight.target.position.set(0, 0, 0);
    spotLight.angle = Math.PI / 6;
    spotLight.penumbra = 0.3;
    scene.add(spotLight);
    scene.add(spotLight.target);
  };

  // ËºâÂÖ•Ë°óÊ©üÊ®°Âûã
  const loadArcadeModel = (scene: THREE.Scene) => {
    const loader = new GLTFLoader();
    loader.load(
      '/src/arcade.glb',
      (gltf) => {
        console.log('GLBÊ®°ÂûãËºâÂÖ•ÊàêÂäüÔºÅ', gltf);
        const arcadeModel = gltf.scene;
        
        // Ë™øÊï¥Ê®°ÂûãÂ§ßÂ∞èÂíå‰ΩçÁΩÆ
        arcadeModel.scale.set(0.8, 0.8, 0.8);
        arcadeModel.position.set(0, -0.8, 0);
        
        // ÂïüÁî®Èô∞ÂΩ±ÂíåÊîπÂñÑÊùêË≥™
        arcadeModel.traverse((child) => {
          if (child instanceof THREE.Mesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            
            // ÊîπÂñÑÊùêË≥™
            if (child.material instanceof THREE.MeshStandardMaterial) {
              child.material.color.setHex(0x2a4a6a);
              child.material.metalness = 0.4;
              child.material.roughness = 0.6;
              child.material.envMapIntensity = 0.5;
            } else if (child.material instanceof THREE.MeshBasicMaterial) {
              child.material.color.setHex(0x2a4a6a);
            }
          }
        });
        
        scene.add(arcadeModel);
        arcadeModelRef.current = arcadeModel as unknown as THREE.Group;
        
        console.log('Ë°óÊ©üÊ®°ÂûãÂ∑≤Ê∑ªÂä†Âà∞Â†¥ÊôØÔºÅ');
      },
      (progress) => {
        if (progress.total > 0) {
          const percent = Math.round((progress.loaded / progress.total) * 100);
          console.log(`üìà Ê®°ÂûãËºâÂÖ•ÈÄ≤Â∫¶: ${percent}%`);
        }
      },
      (error) => {
        console.error('‚ùå ËºâÂÖ•Ê®°ÂûãÊôÇÁôºÁîüÈåØË™§:', error);
        createFallbackModel(scene);
      }
    );
  };

  // ÂâµÂª∫ÂÇôÁî®Ê®°Âûã
  const createFallbackModel = (scene: THREE.Scene) => {
    // ÂâµÂª∫Ë°óÊ©üÂ§ñÊÆº
    const geometry = new THREE.BoxGeometry(2.2, 3.2, 1.2);
    const material = new THREE.MeshPhongMaterial({ 
      color: 0x2a4a6a,
      shininess: 30,
    });
    const arcadeBody = new THREE.Mesh(geometry, material);
    arcadeBody.position.set(0, -0.8, 0);
    arcadeBody.castShadow = true;
    arcadeBody.receiveShadow = true;
    scene.add(arcadeBody);

    // ÂâµÂª∫Ëû¢ÂπïÊ°ÜÊû∂
    const screenGeometry = new THREE.BoxGeometry(1.8, 1.2, 0.1);
    const screenMaterial = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });
    const screenFrame = new THREE.Mesh(screenGeometry, screenMaterial);
    screenFrame.position.set(0, 0.2, 0.6);
    scene.add(screenFrame);

    arcadeModelRef.current = arcadeBody as unknown as THREE.Group;
    console.log('üîÑ ÂÇôÁî®Ê®°ÂûãÂâµÂª∫ÂÆåÊàê');
  };

  // ÂâµÂª∫ÈÅäÊà≤Áï´Èù¢
  const createGameDisplay = (scene: THREE.Scene) => {
    const canvas = document.createElement('canvas');
    canvas.width = 800;
    canvas.height = 600;
    const ctx = canvas.getContext('2d')!;
    
    // Áπ™Ë£ΩÂàùÂßãÁï´Èù¢
    drawGameScreen(ctx, gameState);
    
    // ÂâµÂª∫ÊùêË≥™
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    const material = new THREE.MeshBasicMaterial({ map: texture });
    
    // ÂâµÂª∫Âπ≥Èù¢
    const geometry = new THREE.PlaneGeometry(1.6, 1.2);
    const gameDisplay = new THREE.Mesh(geometry, material);
    gameDisplay.position.set(0, 0.2, 0.65);
    gameDisplay.rotation.x = -Math.PI / 12;
    
    scene.add(gameDisplay);
    gameDisplayRef.current = gameDisplay;
  };

  // Áπ™Ë£ΩÈÅäÊà≤Áï´Èù¢
  const drawGameScreen = (ctx: CanvasRenderingContext2D, gameState: GameState) => {
    // Ê∏ÖÁ©∫Áï´Â∏É
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 800, 600);
    
    if (gameState.gameMode === 'pacman' && gameState.pacman) {
      drawPacmanGame(ctx, gameState);
    } else if (gameState.gameMode === 'space_invaders' && gameState.spaceInvaders) {
      drawSpaceInvadersGame(ctx, gameState);
    } else if (gameState.gameMode === 'snake' && gameState.snake) {
      drawSnakeGame(ctx, gameState);
    } else {
      // È†êË®≠Áï´Èù¢
      ctx.fillStyle = '#FFF';
      ctx.font = 'bold 32px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('3D Ë°óÊ©üÈÅäÊà≤', 400, 280);
      ctx.font = 'bold 24px Arial';
      ctx.fillText('React TypeScript ÁâàÊú¨', 400, 320);
      ctx.font = '18px Arial';
      ctx.fillText('ÈÅ∏ÊìáÈÅäÊà≤Ê®°ÂºèÈñãÂßãÈÅäÊà≤', 400, 360);
    }
  };

  // Áπ™Ë£Ω Pacman ÈÅäÊà≤
  const drawPacmanGame = (ctx: CanvasRenderingContext2D, gameState: GameState) => {
    const pacman = gameState.pacman!;
    
    // Áπ™Ë£ΩÈªûÈªû
    pacman.dots.forEach(dot => {
      if (!dot.eaten) {
        ctx.fillStyle = '#FFD700';
        ctx.beginPath();
        ctx.arc(dot.x, dot.y, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Áπ™Ë£ΩÂ≠óÊØç
        ctx.fillStyle = '#FFF';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(String.fromCharCode(dot.letter), dot.x, dot.y + 4);
      }
    });
    
    // Áπ™Ë£Ω Pacman
    ctx.fillStyle = '#FFFF00';
    ctx.beginPath();
    ctx.arc(pacman.x, pacman.y, 10, 0, Math.PI * 2);
    ctx.fill();
    
    // Áπ™Ë£ΩÂò¥Â∑¥
    if (pacman.mouthOpen) {
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(pacman.x, pacman.y, 10, pacman.direction * Math.PI / 2 - 0.3, pacman.direction * Math.PI / 2 + 0.3);
      ctx.lineTo(pacman.x, pacman.y);
      ctx.fill();
    }
  };

  // Áπ™Ë£Ω Space Invaders ÈÅäÊà≤
  const drawSpaceInvadersGame = (ctx: CanvasRenderingContext2D, gameState: GameState) => {
    const spaceInvaders = gameState.spaceInvaders!;
    
    // Áπ™Ë£ΩÂ§ñÊòü‰∫∫
    spaceInvaders.invaders.forEach(invader => {
      if (invader.alive) {
        ctx.fillStyle = '#FF0000';
        ctx.fillRect(invader.x - 15, invader.y - 10, 30, 20);
        
        // Áπ™Ë£ΩÂ≠óÊØç
        ctx.fillStyle = '#FFF';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(String.fromCharCode(invader.letter), invader.x, invader.y + 5);
      }
    });
    
    // Áπ™Ë£ΩÁé©ÂÆ∂
    ctx.fillStyle = '#00FF00';
    ctx.fillRect(spaceInvaders.player.x - 25, spaceInvaders.player.y - 5, 50, 10);
    
    // Áπ™Ë£ΩÁé©ÂÆ∂Â≠êÂΩà
    spaceInvaders.bullets.forEach(bullet => {
      ctx.fillStyle = '#FFFF00';
      ctx.fillRect(bullet.x - 2, bullet.y - 5, 4, 10);
    });
    
    // Áπ™Ë£ΩÊïµ‰∫∫Â≠êÂΩàÔºàÁ¥ÖËâ≤ÔºåÊõ¥Â§ßÔºâ
    spaceInvaders.invaderBullets.forEach(bullet => {
      ctx.fillStyle = '#FF0000';
      ctx.fillRect(bullet.x - 4, bullet.y - 8, 8, 16); // ÊØîÁé©ÂÆ∂Â≠êÂΩàÂ§ß‰∏ÄÂÄç
    });
    
    // Áπ™Ë£ΩÁàÜÁÇ∏ÊïàÊûú
    spaceInvaders.explosions.forEach(explosion => {
      ctx.globalAlpha = explosion.opacity;
      ctx.fillStyle = explosion.color;
      ctx.beginPath();
      ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    });
  };

  // Áπ™Ë£ΩË≤™È£üËõáÈÅäÊà≤
  const drawSnakeGame = (ctx: CanvasRenderingContext2D, gameState: GameState) => {
    const snake = gameState.snake!;
    
    // Áπ™Ë£ΩÁ∂≤Ê†ºËÉåÊôØ
    ctx.strokeStyle = '#333333';
    ctx.lineWidth = 1;
    for (let x = 0; x < 800; x += snake.gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, 600);
      ctx.stroke();
    }
    for (let y = 0; y < 600; y += snake.gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(800, y);
      ctx.stroke();
    }
    
    // Áπ™Ë£ΩËõáË∫´
    snake.snake.forEach((segment, index) => {
      if (index === 0) {
        // ËõáÈ†≠ - Á∂†Ëâ≤
        ctx.fillStyle = '#00FF00';
      } else {
        // ËõáË∫´ - Ê∑∫Á∂†Ëâ≤
        ctx.fillStyle = '#90EE90';
      }
      
      const x = segment.x * snake.gridSize;
      const y = segment.y * snake.gridSize;
      ctx.fillRect(x + 1, y + 1, snake.gridSize - 2, snake.gridSize - 2);
      
      // Áπ™Ë£ΩËõáÈ†≠ÁöÑÊúùÂêë
      if (index === 0) {
        ctx.fillStyle = '#000000';
        const centerX = x + snake.gridSize / 2;
        const centerY = y + snake.gridSize / 2;
        const eyeSize = 3;
        
        switch (snake.direction) {
          case 0: // Âè≥
            ctx.fillRect(centerX + 3, centerY - 2, eyeSize, eyeSize);
            ctx.fillRect(centerX + 3, centerY + 2, eyeSize, eyeSize);
            break;
          case 1: // ‰∏ã
            ctx.fillRect(centerX - 2, centerY + 3, eyeSize, eyeSize);
            ctx.fillRect(centerX + 2, centerY + 3, eyeSize, eyeSize);
            break;
          case 2: // Â∑¶
            ctx.fillRect(centerX - 6, centerY - 2, eyeSize, eyeSize);
            ctx.fillRect(centerX - 6, centerY + 2, eyeSize, eyeSize);
            break;
          case 3: // ‰∏ä
            ctx.fillRect(centerX - 2, centerY - 6, eyeSize, eyeSize);
            ctx.fillRect(centerX + 2, centerY - 6, eyeSize, eyeSize);
            break;
        }
      }
    });
    
    // Áπ™Ë£ΩÈ£üÁâ©
    ctx.fillStyle = '#FF0000';
    const foodX = snake.food.x * snake.gridSize;
    const foodY = snake.food.y * snake.gridSize;
    ctx.fillRect(foodX + 2, foodY + 2, snake.gridSize - 4, snake.gridSize - 4);
    
    // Áπ™Ë£ΩÈ£üÁâ©‰∏äÁöÑÂ≠óÊØç
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(
      String.fromCharCode(snake.food.letter),
      foodX + snake.gridSize / 2,
      foodY + snake.gridSize / 2 + 4
    );
    
    // Áπ™Ë£ΩÈÅäÊà≤ÁµêÊùüÁï´Èù¢
    if (snake.gameOver) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, 800, 600);
      
      ctx.fillStyle = '#FF0000';
      ctx.font = 'bold 48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('ÈÅäÊà≤ÁµêÊùüÔºÅ', 400, 250);
      
      ctx.fillStyle = '#FFFFFF';
      ctx.font = 'bold 24px Arial';
      ctx.fillText(`ÊúÄÁµÇÂàÜÊï∏: ${gameState.score}`, 400, 300);
      
      ctx.font = '18px Arial';
      ctx.fillText('ÊåâÈáçÁΩÆÊåâÈàïÈáçÊñ∞ÈñãÂßã', 400, 350);
    }
  };

  // Êõ¥Êñ∞Áõ∏Ê©ü‰ΩçÁΩÆ
  const updateCameraPosition = () => {
    if (!cameraRef.current) return;
    
    const currentMode = cameraState.viewModes[cameraState.currentViewMode];
    const camera = cameraRef.current;
    
    // Âπ≥ÊªëÈÅéÊ∏°Âà∞ÁõÆÊ®ô‰ΩçÁΩÆ
    camera.position.lerp(
      new THREE.Vector3(currentMode.position.x, currentMode.position.y, currentMode.position.z),
      0.05
    );
    camera.lookAt(currentMode.target.x, currentMode.target.y, currentMode.target.z);
  };

  // Êõ¥Êñ∞ÈÅäÊà≤Áï´Èù¢
  const updateGameDisplay = () => {
    if (!gameDisplayRef.current) return;
    
    const material = gameDisplayRef.current.material as THREE.MeshBasicMaterial;
    if (!material.map) return;
    
    const texture = material.map as THREE.CanvasTexture;
    const canvas = texture.image as HTMLCanvasElement;
    const ctx = canvas.getContext('2d')!;
    
    drawGameScreen(ctx, gameState);
    texture.needsUpdate = true;
  };

  // ÂâµÂª∫ÂΩ©Ëâ≤Á≤íÂ≠êÁ≥ªÁµ±
  const createParticleSystem = (scene: THREE.Scene) => {
    const particleCount = 200; // Â¢ûÂä†Á≤íÂ≠êÊï∏ÈáèËÆìÊïàÊûúÊõ¥Ë±êÂØå
    const particles = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      
      // ÂúçÁπûÈÅäÊà≤Ê©üÁöÑÁí∞ÂΩ¢ÂàÜ‰Ωà
      const radius = 3 + Math.random() * 4;
      const angle = Math.random() * Math.PI * 2;
      
      // Ë™øÊï¥È´òÂ∫¶ÂàÜ‰ΩàÔºåÂú®Â∫ïÈÉ®Ê∑ªÂä†Êõ¥Â§öÁ≤íÂ≠ê
      let height;
      if (i < 50) {
        // Ââç50ÂÄãÁ≤íÂ≠êÂ∞àÈñÄÊîæÂú®Â∫ïÈÉ®
        height = -2 - Math.random() * 1.5;
      } else {
        // ÂÖ∂‰ªñÁ≤íÂ≠ê‰øùÊåÅÂéüÊú¨ÁöÑÂàÜ‰Ωà
        height = (Math.random() - 0.5) * 5;
      }
      
      positions[i3] = Math.cos(angle) * radius;
      positions[i3 + 1] = height;
      positions[i3 + 2] = Math.sin(angle) * radius;
      
      // Èö®Ê©üÈ°èËâ≤ÔºàÈúìËôπËâ≤Á≥ªÔºâ
      const colorChoice = Math.random();
      if (colorChoice < 0.2) {
        colors[i3] = 1.0; colors[i3 + 1] = 0.2; colors[i3 + 2] = 0.2; // Á¥ÖËâ≤
      } else if (colorChoice < 0.4) {
        colors[i3] = 0.2; colors[i3 + 1] = 1.0; colors[i3 + 2] = 0.2; // Á∂†Ëâ≤
      } else if (colorChoice < 0.6) {
        colors[i3] = 0.2; colors[i3 + 1] = 0.2; colors[i3 + 2] = 1.0; // ËóçËâ≤
      } else if (colorChoice < 0.8) {
        colors[i3] = 1.0; colors[i3 + 1] = 1.0; colors[i3 + 2] = 0.2; // ÈªÉËâ≤
      } else {
        colors[i3] = 1.0; colors[i3 + 1] = 0.2; colors[i3 + 2] = 1.0; // Á¥´Ëâ≤
      }
    }
    
    particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
      size: 0.3,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    
    const particleSystem = new THREE.Points(particles, particleMaterial);
    scene.add(particleSystem);
    particlesRef.current = particleSystem;
    
    console.log('üéÜ ÂΩ©Ëâ≤Á≤íÂ≠êÁ≥ªÁµ±ÂâµÂª∫ÂÆåÊàê');
  };

  // Êõ¥Êñ∞Á≤íÂ≠êÂãïÁï´
  const updateParticleAnimation = () => {
    if (!particlesRef.current) return;
    
    const time = Date.now() * 0.001;
    
    // ÊóãËΩâÁ≤íÂ≠êÁ≥ªÁµ±
    particlesRef.current.rotation.y += 0.002;
    particlesRef.current.rotation.x += 0.001;
    
    // ÂãïÊÖãË™øÊï¥Á≤íÂ≠êÂ§ßÂ∞èÂíåÈÄèÊòéÂ∫¶
    const material = particlesRef.current.material as THREE.PointsMaterial;
    material.size = 0.3 + Math.sin(time) * 0.1;
    material.opacity = 0.8 + Math.sin(time * 0.5) * 0.2;
  };

  return null; // ÈÄôÂÄãÁµÑ‰ª∂Âè™Ë≤†Ë≤¨3DÊ∏≤ÊüìÔºå‰∏çÈúÄË¶ÅËøîÂõûJSX
};
